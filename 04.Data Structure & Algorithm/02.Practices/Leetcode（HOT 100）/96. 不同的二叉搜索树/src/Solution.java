

/*二叉搜索树：
* 1.空树是二叉搜索树。
* 2.若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值。
* 3.若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值。
* 4.左、右子树也都是二叉搜索树。
* */
public class Solution {
    /*思路：
    * G(n): 长度为 n 的序列能构成的不同二叉搜索树的个数。
    * F(i, n): 以 i 为根、序列长度为 n 的不同二叉搜索树个数(1≤i≤n)。
    * 不同的二叉搜索树的总数 G(n)，是对遍历所有 i (1≤i≤n) 的 F(i, n) 之和。
    * base case： G(0) = G(1) = 1
    * 注意到 G(n) 和序列的内容无关，只和序列的长度有关。
    * F(i,n) = G(i−1) * G(n−i)
    * 以动态规划代替递归。
    */
    public int numTrees(int n) {
        int[] G = new int[n + 1];
        G[0] = 1;
        G[1] = 1;

        // i 代表树上节点的总数
        for (int i = 2; i <= n; ++i) {
            // j 代表以哪个节点做头
            for (int j = 1; j <= i; ++j) {
                G[i] += G[j - 1] * G[i - j];
            }
        }
        return G[n];
    }
}